---
description: USE WHEN starting feature work, running /bdd, resuming a BDD ticket, or user says 'add', 'implement', 'build', 'feature', 'resume', 'continue'. Orchestrates BDD phases.
alwaysApply: false
---

# BDD Orchestrator

Behavior-first development for features. Discovery → Scenarios → Implementation.

**Iron Law:** DEFINE BEHAVIOR BEFORE IMPLEMENTATION

## Phase Tracking

Track in ticket frontmatter:

```yaml
---
type: feature
phase: implement # intake | define-behavior | scenario-gate | decomposition | implement | done
---
```

| Phase             | What happens                         | Rule file            |
| ----------------- | ------------------------------------ | -------------------- |
| `intake`          | Context check, discovery (Phase 0-2) | bdd-discovery.mdc    |
| `define-behavior` | Writing Given/When/Then (Phase 3)    | bdd-scenarios.mdc    |
| `scenario-gate`   | Validating scenarios (Phase 4)       | bdd-scenarios.mdc    |
| `decomposition`   | Task breakdown (Phase 5)             | bdd-decomposition.mdc|
| `implement`       | Outside-in TDD (Phase 6)             | bdd-tdd.mdc          |
| `done`            | Cleanup, verification (Phase 7)      | bdd-done.mdc         |

## Resume Logic

1. **Read ticket** → get current `phase:`
2. **Find progress** → first unchecked `[ ]` in test-definitions
3. **Announce resume** → "Resuming at [phase]. Last: [log entry]."

## Current Behavior

1. Detect work level (SAFEWORD.md "Work Level Detection")
2. If ticket exists → resume at current phase
3. Artifact-first: create ticket/test-definitions before work
4. Execute phase using appropriate rule file
5. Update phase in ticket when transitioning

## Key Takeaways

- **patch/task** → TDD directly
- **feature** → full BDD flow, track `phase:` field
- **Resume** → read ticket, find unchecked scenario
- **Split** → see bdd-splitting.mdc
- **Done** → run /done before marking complete
