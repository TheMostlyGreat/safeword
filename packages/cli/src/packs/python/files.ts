/**
 * Python Language Pack - Schema Definitions
 *
 * All Python-specific file definitions and config generators.
 * Imported by schema.ts and spread into SAFEWORD_SCHEMA.
 *
 * Mirrors the structure of typescript/files.ts and golang/files.ts for consistency.
 */

import type { FileDefinition, ManagedFileDefinition } from "../types.js";
import { detectPythonLayers, detectRootPackage } from "./setup.js";

// ============================================================================
// Shared Ruff Configuration
// ============================================================================

/**
 * Shared Ruff lint rules for .safeword/ruff.toml.
 * Used by both standalone and extending configs.
 */
const RUFF_LINT_RULES = `[lint]
select = ["ALL"]
ignore = [
    "D",      # pydocstyle - too noisy for LLM code
    "ANN",    # flake8-annotations - mypy handles this
    "COM812", # missing trailing comma - conflicts with formatter
    "ISC001", # single-line-implicit-string-concatenation - conflicts with formatter
    "E501",   # line too long - formatter handles this
]

[lint.per-file-ignores]
"tests/**" = ["S101"]  # allow assert in tests

[lint.mccabe]
max-complexity = 10`;

// ============================================================================
// Config Generators for .safeword/ (ownedFiles)
// ============================================================================

/**
 * Generate Ruff configuration for .safeword/ruff.toml.
 *
 * If project has existing ruff config, extends it with stricter rules.
 * Otherwise generates standalone config.
 *
 * Used by hooks via --config .safeword/ruff.toml flag.
 *
 * @param existingRuffConfig - True if project has existing ruff config
 */
function generateRuffBaseConfig(existingRuffConfig = false): string {
  if (existingRuffConfig) {
    // Extend project's existing Ruff config with safeword's stricter rules
    // Note: Ruff's extend works with both ruff.toml and pyproject.toml
    // Using pyproject.toml as the extend target covers both cases since:
    // - If [tool.ruff] exists in pyproject.toml, it will be extended
    // - If ruff.toml exists, ruff reads it first, then pyproject.toml is a no-op fallback
    return `# Safeword Ruff config - extends project config with stricter rules
# Used by hooks for LLM enforcement. Human pre-commits use project config.
# Re-run \`safeword upgrade\` to regenerate after project config changes.

# Inherit from project's pyproject.toml [tool.ruff] section
extend = "../pyproject.toml"

# Safeword overrides (stricter than project defaults)
line-length = 100

${RUFF_LINT_RULES}
`;
  }

  // Standalone config (no project config to extend)
  return `# Generated by safeword - DO NOT EDIT
# Customize by creating ruff.toml at project root

line-length = 100

${RUFF_LINT_RULES}
`;
}

// ============================================================================
// Owned Files (overwritten on upgrade)
// ============================================================================

/**
 * Python owned files for .safeword/ directory.
 * These are overwritten on upgrade if content changed.
 */
export const pythonOwnedFiles: Record<string, FileDefinition> = {
  // Ruff config for hooks (extends project config if exists)
  ".safeword/ruff.toml": {
    generator: (ctx) =>
      ctx.languages?.python
        ? generateRuffBaseConfig(ctx.projectType.existingRuffConfig)
        : undefined,
  },
};

// ============================================================================
// Config Generators for project root (managedFiles)
// ============================================================================

/**
 * Generate standalone ruff.toml for project root.
 * Extends .safeword/ruff.toml to get strict rules.
 */
function generateProjectRuffConfig(): string {
  return `# Generated by safeword
# Add your project-specific overrides here.
# Safeword's strict rules are in .safeword/ruff.toml

extend = ".safeword/ruff.toml"

# Project overrides (add your customizations below)
`;
}

/**
 * Generate standalone mypy.ini for project root.
 * Strict config for LLM agents - enforces type annotations.
 */
function generateProjectMypyConfig(): string {
  return `# Generated by safeword
# Strict config for LLM agents - type annotations enforced.

[mypy]
strict = True
warn_unreachable = True
ignore_missing_imports = True
show_error_codes = True
pretty = True
`;
}

/**
 * Generate standalone .importlinter for project root.
 *
 * @param layers - Detected layers (e.g., ['domain', 'services', 'api'])
 * @param rootPackage - Root package name for the project
 */
function generateProjectImportLinterConfig(
  layers: string[],
  rootPackage: string,
): string {
  if (layers.length < 2) return "";

  const layerList = layers.map((l) => `    ${rootPackage}.${l}`).join("\n");

  return `# Generated by safeword
# Layer architecture contracts - enforces clean dependencies

[importlinter]
root_packages = ${rootPackage}

[importlinter:contract:layers]
name = Layer architecture
type = layers
layers =
${layerList}
`;
}

// ============================================================================
// Managed Files (create if missing, reconciled on reset/upgrade)
// ============================================================================

export const pythonManagedFiles: Record<string, ManagedFileDefinition> = {
  // Project-level ruff config (created only if no existing ruff config)
  "ruff.toml": {
    generator: (ctx) => {
      // Skip if not a Python project
      if (!ctx.languages?.python) return;
      // Skip if project already has ruff config
      if (ctx.projectType.existingRuffConfig) return;
      return generateProjectRuffConfig();
    },
  },

  // Project-level mypy config (created only if no existing mypy config)
  "mypy.ini": {
    generator: (ctx) => {
      // Skip if not a Python project
      if (!ctx.languages?.python) return;
      // Skip if project already has mypy config
      if (ctx.projectType.existingMypyConfig) return;
      return generateProjectMypyConfig();
    },
  },

  // Project-level import-linter config (created only if layers detected and no existing config)
  ".importlinter": {
    generator: (ctx) => {
      // Skip if not a Python project
      if (!ctx.languages?.python) return;
      // Skip if project already has import-linter config
      if (ctx.projectType.existingImportLinterConfig) return;

      // Detect layers
      const layers = detectPythonLayers(ctx.cwd);
      if (layers.length < 2) return;

      const rootPackage = detectRootPackage(ctx.cwd);
      return generateProjectImportLinterConfig(layers, rootPackage);
    },
  },
};
